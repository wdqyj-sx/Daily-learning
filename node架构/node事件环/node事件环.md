### node事件环
> node中事件环和浏览器的事件环并不相同
* node中有6个任务队列，当同步任务完成后，异步任务会根据类型分别放入这6个任务队列中，且这六个队列的执行顺序也不相同
   ┌───────────────────────────────────┐
┌─>│timers(计时器)执行                  │
│  |setTimeout以及setInterval的回调     │
│  └──────────┬────────────────────────┘
│  ┌──────────┴────────────┐
│  │     I/O callbacks     │
│   处理网络，流，TCP的错误  │  
│  │      callback      │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     idle, prepare     │
│  │    node内部使用        │
│  └──────────┬────────────┘      ┌───────────────┐
│  ┌──────────┴────────────┐      │   incoming:   │
│  │poll（轮询）            │<─────┤  connections, │
│  │ 执行poll中的i/o队列检查 │      │data, etc.    │
│  │定时器是否到时          │      └───────────────┘
│  └──────────┬────────────┘          
│  ┌──────────┴────────────┐      
│  │        check          │
│  │  存放setImmediate回调  │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
└──┤    close callbacks    │
   │ 关闭的回调例如         │
   │ socket.on('close')    │
   └───────────────────────┘

* 当同步任务执行完之后，会从timer任务开始执行，然后这里的回调执行完，依次向下找下一个队列
* timer里存储的是定时器回调，当定时器时间到达，循环机制跳回到这个队列，执行里面的回调，否则走下面的队列
```js
    setTimeout(function(){
        console.log('setTimeout')
    },0)

    setImmediate(function(){
        console.log('setImmediate')
    })
```
* 根据之前的解释，如果定时器到时间，那么timer里面关于该定时器的回调会执行，然后，再执行后面的队列，而check队列，明显再timer队列之后
* 但是上述代码的输出却不确定
  * 因为在同步运行的时候，虽然定时器是0，但是代码可能因为性能或者其它原因，开始计时的时间不确定，因此同步执行完之后，可能计时器还没开始工作，因此timer队列可能不会先执行，而是执行后面的队列，后面定时器到时间了，反过来执行timer
  * 因此上述代码谁先输出不确定
```js
    require('fs').readFile('./node事件环.md',(err,data)=>{
        setTimeout(function(){
            console.log('setTimeout')
        },0)

        setImmediate(function(){
            console.log('setImmediate')
        })
    })
```
* 上述结果输出setImmediate、setTimeout
* 在第一轮循环机制中，check没有内容，因此循环会停留（堵塞）在poll轮询队列中，等待其出现内容，或者timer中时间到，调用其回调
* 在等到poll中有了回调后，开始执行回调，
* 然后进入下一个队列执行内容
* 下一个队列为check队列，所以执行setImmediate